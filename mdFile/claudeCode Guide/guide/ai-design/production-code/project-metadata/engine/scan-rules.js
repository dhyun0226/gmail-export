/**
 * ÌîÑÎ°úÏ†ùÌä∏ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏàòÏßëÏùÑ ÏúÑÌïú Ïä§Ï∫î Í∑úÏπô ÏóîÏßÑ
 * AI ÌôîÎ©¥ ÏÑ§Í≥Ñ ÎèÑÍµ¨ÏóêÏÑú ÏÇ¨Ïö©ÌïòÎäî Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏûêÎèô ÏÉùÏÑ± Î°úÏßÅ
 */

const fs = require('fs');
const path = require('path');
const glob = require('glob');

class ProjectMetadataScanner {
  constructor(config) {
    this.config = config;
    this.results = {
      frontend: {},
      backend: {},
      database: {},
      architecture: {},
      infrastructure: {},
      confidence: {}
    };
  }

  /**
   * ÌîÑÎ°úÏ†ùÌä∏ Ïä§Ï∫î Ïã§Ìñâ
   * @param {string} projectPath - Ïä§Ï∫îÌï† ÌîÑÎ°úÏ†ùÌä∏ Í≤ΩÎ°ú
   * @param {string} mode - Ïä§Ï∫î Î™®Îìú (standard, deep, fast)
   * @returns {Object} Ïä§Ï∫î Í≤∞Í≥º Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
   */
  async scanProject(projectPath, mode = 'standard') {
    console.log(`üîç ÌîÑÎ°úÏ†ùÌä∏ Ïä§Ï∫î ÏãúÏûë: ${projectPath} (${mode} Î™®Îìú)`);
    
    const scanConfig = this.config.scan_config.scan_modes[mode];
    const startTime = Date.now();

    try {
      // 1Îã®Í≥Ñ: ÌååÏùº Î™©Î°ù ÏàòÏßë
      const files = await this.collectFiles(projectPath, scanConfig);
      console.log(`üìÅ Î∞úÍ≤¨Îêú ÌååÏùº: ${files.length}Í∞ú`);

      // 2Îã®Í≥Ñ: ÌîÑÎ°†Ìä∏ÏóîÎìú Î∂ÑÏÑù
      await this.analyzeFrontend(files);
      
      // 3Îã®Í≥Ñ: Î∞±ÏóîÎìú Î∂ÑÏÑù
      await this.analyzeBackend(files);
      
      // 4Îã®Í≥Ñ: Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∂ÑÏÑù
      await this.analyzeDatabase(files);
      
      // 5Îã®Í≥Ñ: ÏïÑÌÇ§ÌÖçÏ≤ò Î∂ÑÏÑù
      await this.analyzeArchitecture(files);
      
      // 6Îã®Í≥Ñ: Ïù∏ÌîÑÎùº Î∂ÑÏÑù
      await this.analyzeInfrastructure(files);

      // 7Îã®Í≥Ñ: Í≤∞Í≥º Í≤ÄÏ¶ù Î∞è Ïã†Î¢∞ÎèÑ Í≥ÑÏÇ∞
      this.calculateConfidence();

      const elapsed = Date.now() - startTime;
      console.log(`‚úÖ Ïä§Ï∫î ÏôÑÎ£å: ${elapsed}ms`);

      return this.generateMetadata();

    } catch (error) {
      console.error(`‚ùå Ïä§Ï∫î Ïã§Ìå®:`, error);
      throw error;
    }
  }

  /**
   * Ïä§Ï∫î ÎåÄÏÉÅ ÌååÏùº ÏàòÏßë
   */
  async collectFiles(projectPath, scanConfig) {
    const allPatterns = [
      ...this.config.scan_config.file_patterns.frontend.package_files,
      ...this.config.scan_config.file_patterns.frontend.config_files,
      ...this.config.scan_config.file_patterns.frontend.source_files,
      ...this.config.scan_config.file_patterns.backend.java.build_files,
      ...this.config.scan_config.file_patterns.backend.java.config_files,
      ...this.config.scan_config.file_patterns.backend.nodejs.package_files,
      ...this.config.scan_config.file_patterns.infrastructure.docker_files
    ];

    const files = [];
    
    for (const pattern of allPatterns) {
      try {
        const matches = glob.sync(pattern, {
          cwd: projectPath,
          ignore: this.config.scan_config.ignore_patterns,
          nodir: true
        });
        
        for (const match of matches.slice(0, scanConfig.file_limit)) {
          const fullPath = path.join(projectPath, match);
          const stat = fs.statSync(fullPath);
          
          files.push({
            path: match,
            fullPath: fullPath,
            size: stat.size,
            ext: path.extname(match),
            dir: path.dirname(match)
          });
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Ìå®ÌÑ¥ Ïä§Ï∫î Ïã§Ìå®: ${pattern}`, error.message);
      }
    }

    return files.slice(0, scanConfig.file_limit);
  }

  /**
   * ÌîÑÎ°†Ìä∏ÏóîÎìú Í∏∞Ïà†Ïä§ÌÉù Î∂ÑÏÑù
   */
  async analyzeFrontend(files) {
    console.log('üé® ÌîÑÎ°†Ìä∏ÏóîÎìú Î∂ÑÏÑù Ï§ë...');
    
    const packageFiles = files.filter(f => f.path.includes('package.json'));
    
    for (const file of packageFiles) {
      try {
        const content = fs.readFileSync(file.fullPath, 'utf8');
        const packageJson = JSON.parse(content);
        
        // Vue.js Í∞êÏßÄ
        if (this.detectVueJS(packageJson, files)) {
          this.results.frontend.framework = 'Vue 3';
          this.results.frontend.version = this.extractVueVersion(packageJson);
          this.results.confidence.frontend = 95;
        }
        
        // React Í∞êÏßÄ
        else if (this.detectReact(packageJson, files)) {
          this.results.frontend.framework = 'React';
          this.results.frontend.version = this.extractReactVersion(packageJson);
          this.results.confidence.frontend = 95;
        }
        
        // Angular Í∞êÏßÄ
        else if (this.detectAngular(packageJson, files)) {
          this.results.frontend.framework = 'Angular';
          this.results.frontend.version = this.extractAngularVersion(packageJson);
          this.results.confidence.frontend = 95;
        }

        // UI ÎùºÏù¥Î∏åÎü¨Î¶¨ Í∞êÏßÄ
        this.detectUILibraries(packageJson);
        
        // ÎπåÎìú ÎèÑÍµ¨ Í∞êÏßÄ
        this.detectBuildTools(packageJson, files);
        
        // ÏÉÅÌÉú Í¥ÄÎ¶¨ Í∞êÏßÄ
        this.detectStateManagement(packageJson);

      } catch (error) {
        console.warn(`‚ö†Ô∏è package.json Î∂ÑÏÑù Ïã§Ìå®: ${file.path}`);
      }
    }
  }

  /**
   * Vue.js ÌîÑÎ†àÏûÑÏõåÌÅ¨ Í∞êÏßÄ
   */
  detectVueJS(packageJson, files) {
    const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };
    
    // Vue 3 ÏùòÏ°¥ÏÑ± ÌôïÏù∏
    if (deps.vue && (deps.vue.includes('^3') || deps.vue.includes('3.'))) {
      return true;
    }
    
    // Vue ÌååÏùº Ï°¥Ïû¨ ÌôïÏù∏
    const vueFiles = files.filter(f => f.ext === '.vue');
    if (vueFiles.length > 0) {
      return true;
    }
    
    // Vue CLI ÏÑ§Ï†ï ÌôïÏù∏
    if (deps['@vue/cli'] || files.some(f => f.path.includes('vue.config'))) {
      return true;
    }
    
    return false;
  }

  /**
   * React ÌîÑÎ†àÏûÑÏõåÌÅ¨ Í∞êÏßÄ
   */
  detectReact(packageJson, files) {
    const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };
    
    // React ÏùòÏ°¥ÏÑ± ÌôïÏù∏
    if (deps.react) {
      return true;
    }
    
    // JSX/TSX ÌååÏùº Ï°¥Ïû¨ ÌôïÏù∏
    const reactFiles = files.filter(f => ['.jsx', '.tsx'].includes(f.ext));
    if (reactFiles.length > 0) {
      return true;
    }
    
    return false;
  }

  /**
   * Angular ÌîÑÎ†àÏûÑÏõåÌÅ¨ Í∞êÏßÄ
   */
  detectAngular(packageJson, files) {
    const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };
    
    // Angular ÏùòÏ°¥ÏÑ± ÌôïÏù∏
    if (deps['@angular/core']) {
      return true;
    }
    
    // Angular ÏÑ§Ï†ï ÌååÏùº ÌôïÏù∏
    if (files.some(f => f.path.includes('angular.json'))) {
      return true;
    }
    
    return false;
  }

  /**
   * UI ÎùºÏù¥Î∏åÎü¨Î¶¨ Í∞êÏßÄ
   */
  detectUILibraries(packageJson) {
    const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };
    
    // Bootstrap Í¥ÄÎ†®
    if (deps.bootstrap || deps['bootstrap-vue-next']) {
      this.results.frontend.ui_library = 'Bootstrap Vue Next';
      this.results.frontend.ui_version = deps['bootstrap-vue-next'] || deps.bootstrap;
    }
    
    // Material-UI
    else if (deps['@mui/material'] || deps['@material-ui/core']) {
      this.results.frontend.ui_library = 'Material-UI';
      this.results.frontend.ui_version = deps['@mui/material'] || deps['@material-ui/core'];
    }
    
    // Ant Design
    else if (deps.antd) {
      this.results.frontend.ui_library = 'Ant Design';
      this.results.frontend.ui_version = deps.antd;
    }
    
    // DevExtreme
    if (deps.devextreme) {
      this.results.frontend.grid_component = 'DevExtreme';
      this.results.frontend.grid_version = deps.devextreme;
    }
  }

  /**
   * Î∞±ÏóîÎìú Í∏∞Ïà†Ïä§ÌÉù Î∂ÑÏÑù
   */
  async analyzeBackend(files) {
    console.log('‚öôÔ∏è Î∞±ÏóîÎìú Î∂ÑÏÑù Ï§ë...');
    
    // Spring Boot Í∞êÏßÄ
    const pomFiles = files.filter(f => f.path.includes('pom.xml'));
    const gradleFiles = files.filter(f => f.path.includes('build.gradle'));
    
    if (pomFiles.length > 0 || gradleFiles.length > 0) {
      await this.analyzeSpringBoot(pomFiles, gradleFiles);
    }
    
    // Node.js Î∞±ÏóîÎìú Í∞êÏßÄ
    const nodePackageFiles = files.filter(f => 
      f.path.includes('package.json') && 
      !f.path.includes('node_modules') &&
      (f.dir.includes('backend') || f.dir.includes('server') || f.dir.includes('api'))
    );
    
    if (nodePackageFiles.length > 0) {
      await this.analyzeNodeJS(nodePackageFiles);
    }
  }

  /**
   * Spring Boot Î∂ÑÏÑù
   */
  async analyzeSpringBoot(pomFiles, gradleFiles) {
    try {
      // pom.xml Î∂ÑÏÑù
      for (const file of pomFiles) {
        const content = fs.readFileSync(file.fullPath, 'utf8');
        
        if (content.includes('spring-boot-starter')) {
          this.results.backend.framework = 'Spring Boot';
          this.results.backend.language = 'Java';
          this.results.confidence.backend = 95;
          
          // Spring Boot Î≤ÑÏ†Ñ Ï∂îÏ∂ú
          const versionMatch = content.match(/<spring-boot\.version>(.*?)<\/spring-boot\.version>/);
          if (versionMatch) {
            this.results.backend.version = versionMatch[1];
          }
          
          // Ï∂îÍ∞Ä ÏùòÏ°¥ÏÑ± Î∂ÑÏÑù
          if (content.includes('spring-boot-starter-data-jpa')) {
            this.results.backend.orm = 'JPA/Hibernate';
          }
          
          if (content.includes('spring-boot-starter-security')) {
            this.results.backend.security = 'Spring Security';
          }
        }
      }
      
      // build.gradle Î∂ÑÏÑù
      for (const file of gradleFiles) {
        const content = fs.readFileSync(file.fullPath, 'utf8');
        
        if (content.includes('spring-boot')) {
          this.results.backend.framework = 'Spring Boot';
          this.results.backend.language = 'Java';
          this.results.backend.build_tool = 'Gradle';
          this.results.confidence.backend = 95;
        }
      }
      
    } catch (error) {
      console.warn('‚ö†Ô∏è Spring Boot Î∂ÑÏÑù Ïã§Ìå®:', error.message);
    }
  }

  /**
   * Node.js Î∞±ÏóîÎìú Î∂ÑÏÑù
   */
  async analyzeNodeJS(packageFiles) {
    try {
      for (const file of packageFiles) {
        const content = fs.readFileSync(file.fullPath, 'utf8');
        const packageJson = JSON.parse(content);
        const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };
        
        // Express.js Í∞êÏßÄ
        if (deps.express) {
          this.results.backend.framework = 'Express.js';
          this.results.backend.language = 'Node.js';
          this.results.backend.version = deps.express;
          this.results.confidence.backend = 90;
        }
        
        // ORM Í∞êÏßÄ
        if (deps.mongoose) {
          this.results.backend.orm = 'Mongoose';
          this.results.database.primary = 'MongoDB';
        } else if (deps.sequelize) {
          this.results.backend.orm = 'Sequelize';
        }
        
        // Ïù∏Ï¶ù ÎùºÏù¥Î∏åÎü¨Î¶¨ Í∞êÏßÄ
        if (deps.passport) {
          this.results.backend.auth = 'Passport.js';
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Node.js Î∂ÑÏÑù Ïã§Ìå®:', error.message);
    }
  }

  /**
   * Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∂ÑÏÑù
   */
  async analyzeDatabase(files) {
    console.log('üóÑÔ∏è Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∂ÑÏÑù Ï§ë...');
    
    // ÏÑ§Ï†ï ÌååÏùºÏóêÏÑú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ï†ïÎ≥¥ Î∂ÑÏÑù
    const configFiles = files.filter(f => 
      f.path.includes('application.yml') || 
      f.path.includes('application.properties') ||
      f.path.includes('.env')
    );
    
    for (const file of configFiles) {
      try {
        const content = fs.readFileSync(file.fullPath, 'utf8');
        
        // PostgreSQL Í∞êÏßÄ
        if (content.includes('postgresql') || content.includes('postgres')) {
          this.results.database.primary = 'PostgreSQL';
          this.results.confidence.database = 90;
        }
        
        // MySQL Í∞êÏßÄ
        else if (content.includes('mysql')) {
          this.results.database.primary = 'MySQL';
          this.results.confidence.database = 90;
        }
        
        // MongoDB Í∞êÏßÄ
        else if (content.includes('mongodb') || content.includes('mongo')) {
          this.results.database.primary = 'MongoDB';
          this.results.confidence.database = 90;
        }
        
        // Redis Í∞êÏßÄ
        if (content.includes('redis')) {
          this.results.database.cache = 'Redis';
        }
        
      } catch (error) {
        console.warn(`‚ö†Ô∏è ÏÑ§Ï†ï ÌååÏùº Î∂ÑÏÑù Ïã§Ìå®: ${file.path}`);
      }
    }
  }

  /**
   * ÏïÑÌÇ§ÌÖçÏ≤ò Ìå®ÌÑ¥ Î∂ÑÏÑù
   */
  async analyzeArchitecture(files) {
    console.log('üèóÔ∏è ÏïÑÌÇ§ÌÖçÏ≤ò Î∂ÑÏÑù Ï§ë...');
    
    // ÎîîÎ†âÌÜ†Î¶¨ Íµ¨Ï°∞Î°ú ÏïÑÌÇ§ÌÖçÏ≤ò Ìå®ÌÑ¥ Ï∂îÎ°†
    const directories = [...new Set(files.map(f => f.dir))];
    
    // Layered Architecture Í∞êÏßÄ
    const hasController = directories.some(dir => dir.includes('controller'));
    const hasService = directories.some(dir => dir.includes('service'));
    const hasRepository = directories.some(dir => dir.includes('repository'));
    const hasEntity = directories.some(dir => dir.includes('entity') || dir.includes('model'));
    
    if (hasController && hasService && hasRepository) {
      this.results.architecture.pattern = 'Layered Architecture';
      this.results.confidence.architecture = 85;
    }
    
    // ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§ Íµ¨Ï°∞ Í∞êÏßÄ
    const serviceDirectories = directories.filter(dir => 
      dir.includes('-service') || dir.includes('_service')
    );
    
    if (serviceDirectories.length > 1) {
      this.results.architecture.pattern = 'Microservices';
      this.results.confidence.architecture = 80;
    }
    
    // Î™®ÎÖ∏Î¶¨Ïä§ Íµ¨Ï°∞ (Í∏∞Î≥∏Í∞í)
    if (!this.results.architecture.pattern) {
      this.results.architecture.pattern = 'Monolithic';
      this.results.confidence.architecture = 70;
    }
  }

  /**
   * Ïù∏ÌîÑÎùº Î∂ÑÏÑù
   */
  async analyzeInfrastructure(files) {
    console.log('üöÄ Ïù∏ÌîÑÎùº Î∂ÑÏÑù Ï§ë...');
    
    // Docker Í∞êÏßÄ
    const dockerFiles = files.filter(f => f.path.includes('Dockerfile'));
    const dockerComposeFiles = files.filter(f => f.path.includes('docker-compose'));
    
    if (dockerFiles.length > 0 || dockerComposeFiles.length > 0) {
      this.results.infrastructure.container = 'Docker';
      this.results.confidence.infrastructure = 90;
    }
    
    // CI/CD Í∞êÏßÄ
    const ciFiles = files.filter(f => 
      f.path.includes('.github/workflows') ||
      f.path.includes('.gitlab-ci') ||
      f.path.includes('Jenkinsfile')
    );
    
    if (ciFiles.length > 0) {
      this.results.infrastructure.cicd = 'GitHub Actions';
      this.results.confidence.infrastructure = 85;
    }
  }

  /**
   * Ïã†Î¢∞ÎèÑ Í≥ÑÏÇ∞
   */
  calculateConfidence() {
    const confidences = Object.values(this.results.confidence);
    this.results.overall_confidence = confidences.length > 0 
      ? Math.round(confidences.reduce((a, b) => a + b, 0) / confidences.length)
      : 0;
  }

  /**
   * ÏµúÏ¢Ö Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
   */
  generateMetadata() {
    const timestamp = new Date().toISOString();
    
    return {
      metadata_version: "1.0.0",
      schema_version: "2024.1",
      generated_at: timestamp,
      generator: "AI Project Scanner v2.0",
      confidence: this.results.confidence,
      
      projectInfo: {
        name: "scanned-project",
        version: "1.0.0",
        description: "AI Ïä§Ï∫îÏúºÎ°ú ÏÉùÏÑ±Îêú ÌîÑÎ°úÏ†ùÌä∏ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞",
        scanned_at: timestamp
      },
      
      techStack: {
        frontend: {
          framework: this.results.frontend.framework || "Unknown",
          version: this.results.frontend.version || "Unknown",
          ui_library: this.results.frontend.ui_library || "Unknown",
          build_tool: this.detectBuildTool(),
          libs: this.extractFrontendLibs()
        },
        backend: {
          framework: this.results.backend.framework || "Unknown",
          version: this.results.backend.version || "Unknown",
          language: this.results.backend.language || "Unknown",
          orm: this.results.backend.orm || "Unknown",
          libs: this.extractBackendLibs()
        },
        database: {
          primary: this.results.database.primary || "Unknown",
          cache: this.results.database.cache || null
        },
        infrastructure: {
          container: this.results.infrastructure.container || null,
          cicd: this.results.infrastructure.cicd || null
        }
      },
      
      architecture: {
        pattern: this.results.architecture.pattern || "Unknown",
        style: "Monolithic", // Í∏∞Î≥∏Í∞í
        frontend_structure: this.generateFrontendStructure(),
        backend_structure: this.generateBackendStructure()
      },
      
      scan_info: {
        mode: "auto-generated",
        confidence: this.results.overall_confidence,
        recommendations: this.generateRecommendations()
      }
    };
  }

  /**
   * ÎπåÎìú ÎèÑÍµ¨ Í∞êÏßÄ
   */
  detectBuildTool() {
    if (this.results.frontend.framework === 'Vue 3') {
      return 'Vite';
    } else if (this.results.frontend.framework === 'React') {
      return 'Create React App';
    } else if (this.results.frontend.framework === 'Angular') {
      return 'Angular CLI';
    }
    return 'Unknown';
  }

  /**
   * ÌîÑÎ°†Ìä∏ÏóîÎìú ÎùºÏù¥Î∏åÎü¨Î¶¨ Î™©Î°ù Ï∂îÏ∂ú
   */
  extractFrontendLibs() {
    const libs = [];
    
    if (this.results.frontend.ui_library) {
      libs.push({
        name: this.results.frontend.ui_library,
        version: this.results.frontend.ui_version || "Unknown",
        purpose: "UI Components"
      });
    }
    
    if (this.results.frontend.grid_component) {
      libs.push({
        name: this.results.frontend.grid_component,
        version: this.results.frontend.grid_version || "Unknown",
        purpose: "Data Grid"
      });
    }
    
    return libs;
  }

  /**
   * Î∞±ÏóîÎìú ÎùºÏù¥Î∏åÎü¨Î¶¨ Î™©Î°ù Ï∂îÏ∂ú
   */
  extractBackendLibs() {
    const libs = [];
    
    if (this.results.backend.orm) {
      libs.push({
        name: this.results.backend.orm,
        purpose: "ORM"
      });
    }
    
    if (this.results.backend.security) {
      libs.push({
        name: this.results.backend.security,
        purpose: "Security"
      });
    }
    
    return libs;
  }

  /**
   * ÌîÑÎ°†Ìä∏ÏóîÎìú Íµ¨Ï°∞ ÏÉùÏÑ±
   */
  generateFrontendStructure() {
    if (this.results.frontend.framework === 'Vue 3') {
      return {
        layers: [
          {
            name: "Presentation Layer",
            components: ["Vue Components", "Pages", "Layouts"],
            path: "/src/components, /src/pages, /src/layouts"
          },
          {
            name: "State Management Layer",
            components: ["Pinia Stores", "Composables"],
            path: "/src/stores, /src/composables"
          }
        ],
        routing: "Vue Router",
        state_management: "Pinia"
      };
    }
    
    return {
      layers: [],
      routing: "Unknown",
      state_management: "Unknown"
    };
  }

  /**
   * Î∞±ÏóîÎìú Íµ¨Ï°∞ ÏÉùÏÑ±
   */
  generateBackendStructure() {
    if (this.results.backend.framework === 'Spring Boot') {
      return {
        layers: [
          {
            name: "Presentation Layer",
            components: ["REST Controllers", "DTOs"],
            path: "/controller, /dto"
          },
          {
            name: "Business Layer",
            components: ["Services", "Business Logic"],
            path: "/service"
          },
          {
            name: "Persistence Layer",
            components: ["Repositories", "Entities"],
            path: "/repository, /entity"
          }
        ],
        api_pattern: "RESTful API"
      };
    }
    
    return {
      layers: [],
      api_pattern: "Unknown"
    };
  }

  /**
   * Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±
   */
  generateRecommendations() {
    const recommendations = [];
    
    if (this.results.confidence.frontend < 80) {
      recommendations.push("ÌîÑÎ°†Ìä∏ÏóîÎìú ÏÑ§Ï†ïÏùÑ ÏàòÎèôÏúºÎ°ú Í≤ÄÌÜ†ÌïòÏÑ∏Ïöî");
    }
    
    if (this.results.confidence.backend < 80) {
      recommendations.push("Î∞±ÏóîÎìú ÏÑ§Ï†ïÏùÑ ÏàòÎèôÏúºÎ°ú Í≤ÄÌÜ†ÌïòÏÑ∏Ïöî");
    }
    
    if (!this.results.database.primary || this.results.database.primary === 'Unknown') {
      recommendations.push("Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ§Ï†ïÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî");
    }
    
    if (this.results.overall_confidence < 80) {
      recommendations.push("Ïä§Ï∫î Í≤∞Í≥ºÎ•º ÏàòÎèôÏúºÎ°ú Í≤ÄÏ¶ùÌïòÍ≥† ÏàòÏ†ïÌïòÏÑ∏Ïöî");
    }
    
    return recommendations;
  }
}

module.exports = ProjectMetadataScanner;